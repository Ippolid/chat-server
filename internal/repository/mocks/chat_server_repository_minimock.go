// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Ippolid/chat-server/internal/repository.ChatServerRepository -o chat_server_repository_minimock.go -n ChatServerRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Ippolid/chat-server/internal/model"
	"github.com/gojuno/minimock/v3"
)

// ChatServerRepositoryMock implements mm_repository.ChatServerRepository
type ChatServerRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateRequest          func(ctx context.Context, chat model.Chats) (i1 int64, err error)
	funcCreateRequestOrigin    string
	inspectFuncCreateRequest   func(ctx context.Context, chat model.Chats)
	afterCreateRequestCounter  uint64
	beforeCreateRequestCounter uint64
	CreateRequestMock          mChatServerRepositoryMockCreateRequest

	funcDeleteChat          func(ctx context.Context, id int64) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, id int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServerRepositoryMockDeleteChat

	funcMakeLog          func(ctx context.Context, log model.Log) (err error)
	funcMakeLogOrigin    string
	inspectFuncMakeLog   func(ctx context.Context, log model.Log)
	afterMakeLogCounter  uint64
	beforeMakeLogCounter uint64
	MakeLogMock          mChatServerRepositoryMockMakeLog

	funcSendMessage          func(ctx context.Context, message model.MessageInfo) (err error)
	funcSendMessageOrigin    string
	inspectFuncSendMessage   func(ctx context.Context, message model.MessageInfo)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServerRepositoryMockSendMessage
}

// NewChatServerRepositoryMock returns a mock for mm_repository.ChatServerRepository
func NewChatServerRepositoryMock(t minimock.Tester) *ChatServerRepositoryMock {
	m := &ChatServerRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateRequestMock = mChatServerRepositoryMockCreateRequest{mock: m}
	m.CreateRequestMock.callArgs = []*ChatServerRepositoryMockCreateRequestParams{}

	m.DeleteChatMock = mChatServerRepositoryMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServerRepositoryMockDeleteChatParams{}

	m.MakeLogMock = mChatServerRepositoryMockMakeLog{mock: m}
	m.MakeLogMock.callArgs = []*ChatServerRepositoryMockMakeLogParams{}

	m.SendMessageMock = mChatServerRepositoryMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServerRepositoryMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServerRepositoryMockCreateRequest struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockCreateRequestExpectation
	expectations       []*ChatServerRepositoryMockCreateRequestExpectation

	callArgs []*ChatServerRepositoryMockCreateRequestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockCreateRequestExpectation specifies expectation struct of the ChatServerRepository.CreateRequest
type ChatServerRepositoryMockCreateRequestExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockCreateRequestParams
	paramPtrs          *ChatServerRepositoryMockCreateRequestParamPtrs
	expectationOrigins ChatServerRepositoryMockCreateRequestExpectationOrigins
	results            *ChatServerRepositoryMockCreateRequestResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockCreateRequestParams contains parameters of the ChatServerRepository.CreateRequest
type ChatServerRepositoryMockCreateRequestParams struct {
	ctx  context.Context
	chat model.Chats
}

// ChatServerRepositoryMockCreateRequestParamPtrs contains pointers to parameters of the ChatServerRepository.CreateRequest
type ChatServerRepositoryMockCreateRequestParamPtrs struct {
	ctx  *context.Context
	chat *model.Chats
}

// ChatServerRepositoryMockCreateRequestResults contains results of the ChatServerRepository.CreateRequest
type ChatServerRepositoryMockCreateRequestResults struct {
	i1  int64
	err error
}

// ChatServerRepositoryMockCreateRequestOrigins contains origins of expectations of the ChatServerRepository.CreateRequest
type ChatServerRepositoryMockCreateRequestExpectationOrigins struct {
	origin     string
	originCtx  string
	originChat string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) Optional() *mChatServerRepositoryMockCreateRequest {
	mmCreateRequest.optional = true
	return mmCreateRequest
}

// Expect sets up expected params for ChatServerRepository.CreateRequest
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) Expect(ctx context.Context, chat model.Chats) *mChatServerRepositoryMockCreateRequest {
	if mmCreateRequest.mock.funcCreateRequest != nil {
		mmCreateRequest.mock.t.Fatalf("ChatServerRepositoryMock.CreateRequest mock is already set by Set")
	}

	if mmCreateRequest.defaultExpectation == nil {
		mmCreateRequest.defaultExpectation = &ChatServerRepositoryMockCreateRequestExpectation{}
	}

	if mmCreateRequest.defaultExpectation.paramPtrs != nil {
		mmCreateRequest.mock.t.Fatalf("ChatServerRepositoryMock.CreateRequest mock is already set by ExpectParams functions")
	}

	mmCreateRequest.defaultExpectation.params = &ChatServerRepositoryMockCreateRequestParams{ctx, chat}
	mmCreateRequest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateRequest.expectations {
		if minimock.Equal(e.params, mmCreateRequest.defaultExpectation.params) {
			mmCreateRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRequest.defaultExpectation.params)
		}
	}

	return mmCreateRequest
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.CreateRequest
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockCreateRequest {
	if mmCreateRequest.mock.funcCreateRequest != nil {
		mmCreateRequest.mock.t.Fatalf("ChatServerRepositoryMock.CreateRequest mock is already set by Set")
	}

	if mmCreateRequest.defaultExpectation == nil {
		mmCreateRequest.defaultExpectation = &ChatServerRepositoryMockCreateRequestExpectation{}
	}

	if mmCreateRequest.defaultExpectation.params != nil {
		mmCreateRequest.mock.t.Fatalf("ChatServerRepositoryMock.CreateRequest mock is already set by Expect")
	}

	if mmCreateRequest.defaultExpectation.paramPtrs == nil {
		mmCreateRequest.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateRequestParamPtrs{}
	}
	mmCreateRequest.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateRequest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateRequest
}

// ExpectChatParam2 sets up expected param chat for ChatServerRepository.CreateRequest
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) ExpectChatParam2(chat model.Chats) *mChatServerRepositoryMockCreateRequest {
	if mmCreateRequest.mock.funcCreateRequest != nil {
		mmCreateRequest.mock.t.Fatalf("ChatServerRepositoryMock.CreateRequest mock is already set by Set")
	}

	if mmCreateRequest.defaultExpectation == nil {
		mmCreateRequest.defaultExpectation = &ChatServerRepositoryMockCreateRequestExpectation{}
	}

	if mmCreateRequest.defaultExpectation.params != nil {
		mmCreateRequest.mock.t.Fatalf("ChatServerRepositoryMock.CreateRequest mock is already set by Expect")
	}

	if mmCreateRequest.defaultExpectation.paramPtrs == nil {
		mmCreateRequest.defaultExpectation.paramPtrs = &ChatServerRepositoryMockCreateRequestParamPtrs{}
	}
	mmCreateRequest.defaultExpectation.paramPtrs.chat = &chat
	mmCreateRequest.defaultExpectation.expectationOrigins.originChat = minimock.CallerInfo(1)

	return mmCreateRequest
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.CreateRequest
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) Inspect(f func(ctx context.Context, chat model.Chats)) *mChatServerRepositoryMockCreateRequest {
	if mmCreateRequest.mock.inspectFuncCreateRequest != nil {
		mmCreateRequest.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.CreateRequest")
	}

	mmCreateRequest.mock.inspectFuncCreateRequest = f

	return mmCreateRequest
}

// Return sets up results that will be returned by ChatServerRepository.CreateRequest
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) Return(i1 int64, err error) *ChatServerRepositoryMock {
	if mmCreateRequest.mock.funcCreateRequest != nil {
		mmCreateRequest.mock.t.Fatalf("ChatServerRepositoryMock.CreateRequest mock is already set by Set")
	}

	if mmCreateRequest.defaultExpectation == nil {
		mmCreateRequest.defaultExpectation = &ChatServerRepositoryMockCreateRequestExpectation{mock: mmCreateRequest.mock}
	}
	mmCreateRequest.defaultExpectation.results = &ChatServerRepositoryMockCreateRequestResults{i1, err}
	mmCreateRequest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateRequest.mock
}

// Set uses given function f to mock the ChatServerRepository.CreateRequest method
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) Set(f func(ctx context.Context, chat model.Chats) (i1 int64, err error)) *ChatServerRepositoryMock {
	if mmCreateRequest.defaultExpectation != nil {
		mmCreateRequest.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.CreateRequest method")
	}

	if len(mmCreateRequest.expectations) > 0 {
		mmCreateRequest.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.CreateRequest method")
	}

	mmCreateRequest.mock.funcCreateRequest = f
	mmCreateRequest.mock.funcCreateRequestOrigin = minimock.CallerInfo(1)
	return mmCreateRequest.mock
}

// When sets expectation for the ChatServerRepository.CreateRequest which will trigger the result defined by the following
// Then helper
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) When(ctx context.Context, chat model.Chats) *ChatServerRepositoryMockCreateRequestExpectation {
	if mmCreateRequest.mock.funcCreateRequest != nil {
		mmCreateRequest.mock.t.Fatalf("ChatServerRepositoryMock.CreateRequest mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockCreateRequestExpectation{
		mock:               mmCreateRequest.mock,
		params:             &ChatServerRepositoryMockCreateRequestParams{ctx, chat},
		expectationOrigins: ChatServerRepositoryMockCreateRequestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateRequest.expectations = append(mmCreateRequest.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.CreateRequest return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockCreateRequestExpectation) Then(i1 int64, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockCreateRequestResults{i1, err}
	return e.mock
}

// Times sets number of times ChatServerRepository.CreateRequest should be invoked
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) Times(n uint64) *mChatServerRepositoryMockCreateRequest {
	if n == 0 {
		mmCreateRequest.mock.t.Fatalf("Times of ChatServerRepositoryMock.CreateRequest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRequest.expectedInvocations, n)
	mmCreateRequest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateRequest
}

func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) invocationsDone() bool {
	if len(mmCreateRequest.expectations) == 0 && mmCreateRequest.defaultExpectation == nil && mmCreateRequest.mock.funcCreateRequest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRequest.mock.afterCreateRequestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRequest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRequest implements mm_repository.ChatServerRepository
func (mmCreateRequest *ChatServerRepositoryMock) CreateRequest(ctx context.Context, chat model.Chats) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateRequest.beforeCreateRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRequest.afterCreateRequestCounter, 1)

	mmCreateRequest.t.Helper()

	if mmCreateRequest.inspectFuncCreateRequest != nil {
		mmCreateRequest.inspectFuncCreateRequest(ctx, chat)
	}

	mm_params := ChatServerRepositoryMockCreateRequestParams{ctx, chat}

	// Record call args
	mmCreateRequest.CreateRequestMock.mutex.Lock()
	mmCreateRequest.CreateRequestMock.callArgs = append(mmCreateRequest.CreateRequestMock.callArgs, &mm_params)
	mmCreateRequest.CreateRequestMock.mutex.Unlock()

	for _, e := range mmCreateRequest.CreateRequestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateRequest.CreateRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRequest.CreateRequestMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRequest.CreateRequestMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRequest.CreateRequestMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockCreateRequestParams{ctx, chat}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateRequest.t.Errorf("ChatServerRepositoryMock.CreateRequest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRequest.CreateRequestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chat != nil && !minimock.Equal(*mm_want_ptrs.chat, mm_got.chat) {
				mmCreateRequest.t.Errorf("ChatServerRepositoryMock.CreateRequest got unexpected parameter chat, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRequest.CreateRequestMock.defaultExpectation.expectationOrigins.originChat, *mm_want_ptrs.chat, mm_got.chat, minimock.Diff(*mm_want_ptrs.chat, mm_got.chat))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRequest.t.Errorf("ChatServerRepositoryMock.CreateRequest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateRequest.CreateRequestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRequest.CreateRequestMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRequest.t.Fatal("No results are set for the ChatServerRepositoryMock.CreateRequest")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateRequest.funcCreateRequest != nil {
		return mmCreateRequest.funcCreateRequest(ctx, chat)
	}
	mmCreateRequest.t.Fatalf("Unexpected call to ChatServerRepositoryMock.CreateRequest. %v %v", ctx, chat)
	return
}

// CreateRequestAfterCounter returns a count of finished ChatServerRepositoryMock.CreateRequest invocations
func (mmCreateRequest *ChatServerRepositoryMock) CreateRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRequest.afterCreateRequestCounter)
}

// CreateRequestBeforeCounter returns a count of ChatServerRepositoryMock.CreateRequest invocations
func (mmCreateRequest *ChatServerRepositoryMock) CreateRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRequest.beforeCreateRequestCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.CreateRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRequest *mChatServerRepositoryMockCreateRequest) Calls() []*ChatServerRepositoryMockCreateRequestParams {
	mmCreateRequest.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockCreateRequestParams, len(mmCreateRequest.callArgs))
	copy(argCopy, mmCreateRequest.callArgs)

	mmCreateRequest.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRequestDone returns true if the count of the CreateRequest invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockCreateRequestDone() bool {
	if m.CreateRequestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRequestMock.invocationsDone()
}

// MinimockCreateRequestInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockCreateRequestInspect() {
	for _, e := range m.CreateRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateRequest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateRequestCounter := mm_atomic.LoadUint64(&m.afterCreateRequestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRequestMock.defaultExpectation != nil && afterCreateRequestCounter < 1 {
		if m.CreateRequestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateRequest at\n%s", m.CreateRequestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateRequest at\n%s with params: %#v", m.CreateRequestMock.defaultExpectation.expectationOrigins.origin, *m.CreateRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRequest != nil && afterCreateRequestCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.CreateRequest at\n%s", m.funcCreateRequestOrigin)
	}

	if !m.CreateRequestMock.invocationsDone() && afterCreateRequestCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.CreateRequest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRequestMock.expectedInvocations), m.CreateRequestMock.expectedInvocationsOrigin, afterCreateRequestCounter)
	}
}

type mChatServerRepositoryMockDeleteChat struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteChatExpectation
	expectations       []*ChatServerRepositoryMockDeleteChatExpectation

	callArgs []*ChatServerRepositoryMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockDeleteChatExpectation specifies expectation struct of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockDeleteChatParams
	paramPtrs          *ChatServerRepositoryMockDeleteChatParamPtrs
	expectationOrigins ChatServerRepositoryMockDeleteChatExpectationOrigins
	results            *ChatServerRepositoryMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockDeleteChatParams contains parameters of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatParams struct {
	ctx context.Context
	id  int64
}

// ChatServerRepositoryMockDeleteChatParamPtrs contains pointers to parameters of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatServerRepositoryMockDeleteChatResults contains results of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatResults struct {
	err error
}

// ChatServerRepositoryMockDeleteChatOrigins contains origins of expectations of the ChatServerRepository.DeleteChat
type ChatServerRepositoryMockDeleteChatExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Optional() *mChatServerRepositoryMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Expect(ctx context.Context, id int64) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatServerRepositoryMockDeleteChatParams{ctx, id}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServerRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectIdParam2 sets up expected param id for ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) ExpectIdParam2(id int64) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServerRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.id = &id
	mmDeleteChat.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatServerRepositoryMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatServerRepository.DeleteChat
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Return(err error) *ChatServerRepositoryMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServerRepositoryMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServerRepositoryMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteChat method
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatServerRepositoryMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatServerRepository.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) When(ctx context.Context, id int64) *ChatServerRepositoryMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatServerRepositoryMockDeleteChatParams{ctx, id},
		expectationOrigins: ChatServerRepositoryMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteChatExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatServerRepository.DeleteChat should be invoked
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Times(n uint64) *mChatServerRepositoryMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatServerRepositoryMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_repository.ChatServerRepository
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChat(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatServerRepositoryMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockDeleteChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatServerRepositoryMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteChat.t.Errorf("ChatServerRepositoryMock.DeleteChat got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServerRepositoryMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServerRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatServerRepositoryMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServerRepositoryMockDeleteChat) Calls() []*ChatServerRepositoryMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatServerRepositoryMockMakeLog struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockMakeLogExpectation
	expectations       []*ChatServerRepositoryMockMakeLogExpectation

	callArgs []*ChatServerRepositoryMockMakeLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockMakeLogExpectation specifies expectation struct of the ChatServerRepository.MakeLog
type ChatServerRepositoryMockMakeLogExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockMakeLogParams
	paramPtrs          *ChatServerRepositoryMockMakeLogParamPtrs
	expectationOrigins ChatServerRepositoryMockMakeLogExpectationOrigins
	results            *ChatServerRepositoryMockMakeLogResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockMakeLogParams contains parameters of the ChatServerRepository.MakeLog
type ChatServerRepositoryMockMakeLogParams struct {
	ctx context.Context
	log model.Log
}

// ChatServerRepositoryMockMakeLogParamPtrs contains pointers to parameters of the ChatServerRepository.MakeLog
type ChatServerRepositoryMockMakeLogParamPtrs struct {
	ctx *context.Context
	log *model.Log
}

// ChatServerRepositoryMockMakeLogResults contains results of the ChatServerRepository.MakeLog
type ChatServerRepositoryMockMakeLogResults struct {
	err error
}

// ChatServerRepositoryMockMakeLogOrigins contains origins of expectations of the ChatServerRepository.MakeLog
type ChatServerRepositoryMockMakeLogExpectationOrigins struct {
	origin    string
	originCtx string
	originLog string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMakeLog *mChatServerRepositoryMockMakeLog) Optional() *mChatServerRepositoryMockMakeLog {
	mmMakeLog.optional = true
	return mmMakeLog
}

// Expect sets up expected params for ChatServerRepository.MakeLog
func (mmMakeLog *mChatServerRepositoryMockMakeLog) Expect(ctx context.Context, log model.Log) *mChatServerRepositoryMockMakeLog {
	if mmMakeLog.mock.funcMakeLog != nil {
		mmMakeLog.mock.t.Fatalf("ChatServerRepositoryMock.MakeLog mock is already set by Set")
	}

	if mmMakeLog.defaultExpectation == nil {
		mmMakeLog.defaultExpectation = &ChatServerRepositoryMockMakeLogExpectation{}
	}

	if mmMakeLog.defaultExpectation.paramPtrs != nil {
		mmMakeLog.mock.t.Fatalf("ChatServerRepositoryMock.MakeLog mock is already set by ExpectParams functions")
	}

	mmMakeLog.defaultExpectation.params = &ChatServerRepositoryMockMakeLogParams{ctx, log}
	mmMakeLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMakeLog.expectations {
		if minimock.Equal(e.params, mmMakeLog.defaultExpectation.params) {
			mmMakeLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMakeLog.defaultExpectation.params)
		}
	}

	return mmMakeLog
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.MakeLog
func (mmMakeLog *mChatServerRepositoryMockMakeLog) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockMakeLog {
	if mmMakeLog.mock.funcMakeLog != nil {
		mmMakeLog.mock.t.Fatalf("ChatServerRepositoryMock.MakeLog mock is already set by Set")
	}

	if mmMakeLog.defaultExpectation == nil {
		mmMakeLog.defaultExpectation = &ChatServerRepositoryMockMakeLogExpectation{}
	}

	if mmMakeLog.defaultExpectation.params != nil {
		mmMakeLog.mock.t.Fatalf("ChatServerRepositoryMock.MakeLog mock is already set by Expect")
	}

	if mmMakeLog.defaultExpectation.paramPtrs == nil {
		mmMakeLog.defaultExpectation.paramPtrs = &ChatServerRepositoryMockMakeLogParamPtrs{}
	}
	mmMakeLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmMakeLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMakeLog
}

// ExpectLogParam2 sets up expected param log for ChatServerRepository.MakeLog
func (mmMakeLog *mChatServerRepositoryMockMakeLog) ExpectLogParam2(log model.Log) *mChatServerRepositoryMockMakeLog {
	if mmMakeLog.mock.funcMakeLog != nil {
		mmMakeLog.mock.t.Fatalf("ChatServerRepositoryMock.MakeLog mock is already set by Set")
	}

	if mmMakeLog.defaultExpectation == nil {
		mmMakeLog.defaultExpectation = &ChatServerRepositoryMockMakeLogExpectation{}
	}

	if mmMakeLog.defaultExpectation.params != nil {
		mmMakeLog.mock.t.Fatalf("ChatServerRepositoryMock.MakeLog mock is already set by Expect")
	}

	if mmMakeLog.defaultExpectation.paramPtrs == nil {
		mmMakeLog.defaultExpectation.paramPtrs = &ChatServerRepositoryMockMakeLogParamPtrs{}
	}
	mmMakeLog.defaultExpectation.paramPtrs.log = &log
	mmMakeLog.defaultExpectation.expectationOrigins.originLog = minimock.CallerInfo(1)

	return mmMakeLog
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.MakeLog
func (mmMakeLog *mChatServerRepositoryMockMakeLog) Inspect(f func(ctx context.Context, log model.Log)) *mChatServerRepositoryMockMakeLog {
	if mmMakeLog.mock.inspectFuncMakeLog != nil {
		mmMakeLog.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.MakeLog")
	}

	mmMakeLog.mock.inspectFuncMakeLog = f

	return mmMakeLog
}

// Return sets up results that will be returned by ChatServerRepository.MakeLog
func (mmMakeLog *mChatServerRepositoryMockMakeLog) Return(err error) *ChatServerRepositoryMock {
	if mmMakeLog.mock.funcMakeLog != nil {
		mmMakeLog.mock.t.Fatalf("ChatServerRepositoryMock.MakeLog mock is already set by Set")
	}

	if mmMakeLog.defaultExpectation == nil {
		mmMakeLog.defaultExpectation = &ChatServerRepositoryMockMakeLogExpectation{mock: mmMakeLog.mock}
	}
	mmMakeLog.defaultExpectation.results = &ChatServerRepositoryMockMakeLogResults{err}
	mmMakeLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMakeLog.mock
}

// Set uses given function f to mock the ChatServerRepository.MakeLog method
func (mmMakeLog *mChatServerRepositoryMockMakeLog) Set(f func(ctx context.Context, log model.Log) (err error)) *ChatServerRepositoryMock {
	if mmMakeLog.defaultExpectation != nil {
		mmMakeLog.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.MakeLog method")
	}

	if len(mmMakeLog.expectations) > 0 {
		mmMakeLog.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.MakeLog method")
	}

	mmMakeLog.mock.funcMakeLog = f
	mmMakeLog.mock.funcMakeLogOrigin = minimock.CallerInfo(1)
	return mmMakeLog.mock
}

// When sets expectation for the ChatServerRepository.MakeLog which will trigger the result defined by the following
// Then helper
func (mmMakeLog *mChatServerRepositoryMockMakeLog) When(ctx context.Context, log model.Log) *ChatServerRepositoryMockMakeLogExpectation {
	if mmMakeLog.mock.funcMakeLog != nil {
		mmMakeLog.mock.t.Fatalf("ChatServerRepositoryMock.MakeLog mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockMakeLogExpectation{
		mock:               mmMakeLog.mock,
		params:             &ChatServerRepositoryMockMakeLogParams{ctx, log},
		expectationOrigins: ChatServerRepositoryMockMakeLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMakeLog.expectations = append(mmMakeLog.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.MakeLog return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockMakeLogExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockMakeLogResults{err}
	return e.mock
}

// Times sets number of times ChatServerRepository.MakeLog should be invoked
func (mmMakeLog *mChatServerRepositoryMockMakeLog) Times(n uint64) *mChatServerRepositoryMockMakeLog {
	if n == 0 {
		mmMakeLog.mock.t.Fatalf("Times of ChatServerRepositoryMock.MakeLog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMakeLog.expectedInvocations, n)
	mmMakeLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMakeLog
}

func (mmMakeLog *mChatServerRepositoryMockMakeLog) invocationsDone() bool {
	if len(mmMakeLog.expectations) == 0 && mmMakeLog.defaultExpectation == nil && mmMakeLog.mock.funcMakeLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMakeLog.mock.afterMakeLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMakeLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MakeLog implements mm_repository.ChatServerRepository
func (mmMakeLog *ChatServerRepositoryMock) MakeLog(ctx context.Context, log model.Log) (err error) {
	mm_atomic.AddUint64(&mmMakeLog.beforeMakeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmMakeLog.afterMakeLogCounter, 1)

	mmMakeLog.t.Helper()

	if mmMakeLog.inspectFuncMakeLog != nil {
		mmMakeLog.inspectFuncMakeLog(ctx, log)
	}

	mm_params := ChatServerRepositoryMockMakeLogParams{ctx, log}

	// Record call args
	mmMakeLog.MakeLogMock.mutex.Lock()
	mmMakeLog.MakeLogMock.callArgs = append(mmMakeLog.MakeLogMock.callArgs, &mm_params)
	mmMakeLog.MakeLogMock.mutex.Unlock()

	for _, e := range mmMakeLog.MakeLogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMakeLog.MakeLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMakeLog.MakeLogMock.defaultExpectation.Counter, 1)
		mm_want := mmMakeLog.MakeLogMock.defaultExpectation.params
		mm_want_ptrs := mmMakeLog.MakeLogMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockMakeLogParams{ctx, log}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMakeLog.t.Errorf("ChatServerRepositoryMock.MakeLog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMakeLog.MakeLogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.log != nil && !minimock.Equal(*mm_want_ptrs.log, mm_got.log) {
				mmMakeLog.t.Errorf("ChatServerRepositoryMock.MakeLog got unexpected parameter log, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMakeLog.MakeLogMock.defaultExpectation.expectationOrigins.originLog, *mm_want_ptrs.log, mm_got.log, minimock.Diff(*mm_want_ptrs.log, mm_got.log))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMakeLog.t.Errorf("ChatServerRepositoryMock.MakeLog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMakeLog.MakeLogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMakeLog.MakeLogMock.defaultExpectation.results
		if mm_results == nil {
			mmMakeLog.t.Fatal("No results are set for the ChatServerRepositoryMock.MakeLog")
		}
		return (*mm_results).err
	}
	if mmMakeLog.funcMakeLog != nil {
		return mmMakeLog.funcMakeLog(ctx, log)
	}
	mmMakeLog.t.Fatalf("Unexpected call to ChatServerRepositoryMock.MakeLog. %v %v", ctx, log)
	return
}

// MakeLogAfterCounter returns a count of finished ChatServerRepositoryMock.MakeLog invocations
func (mmMakeLog *ChatServerRepositoryMock) MakeLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeLog.afterMakeLogCounter)
}

// MakeLogBeforeCounter returns a count of ChatServerRepositoryMock.MakeLog invocations
func (mmMakeLog *ChatServerRepositoryMock) MakeLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMakeLog.beforeMakeLogCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.MakeLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMakeLog *mChatServerRepositoryMockMakeLog) Calls() []*ChatServerRepositoryMockMakeLogParams {
	mmMakeLog.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockMakeLogParams, len(mmMakeLog.callArgs))
	copy(argCopy, mmMakeLog.callArgs)

	mmMakeLog.mutex.RUnlock()

	return argCopy
}

// MinimockMakeLogDone returns true if the count of the MakeLog invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockMakeLogDone() bool {
	if m.MakeLogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MakeLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MakeLogMock.invocationsDone()
}

// MinimockMakeLogInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockMakeLogInspect() {
	for _, e := range m.MakeLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.MakeLog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMakeLogCounter := mm_atomic.LoadUint64(&m.afterMakeLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MakeLogMock.defaultExpectation != nil && afterMakeLogCounter < 1 {
		if m.MakeLogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.MakeLog at\n%s", m.MakeLogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.MakeLog at\n%s with params: %#v", m.MakeLogMock.defaultExpectation.expectationOrigins.origin, *m.MakeLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMakeLog != nil && afterMakeLogCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.MakeLog at\n%s", m.funcMakeLogOrigin)
	}

	if !m.MakeLogMock.invocationsDone() && afterMakeLogCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.MakeLog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MakeLogMock.expectedInvocations), m.MakeLogMock.expectedInvocationsOrigin, afterMakeLogCounter)
	}
}

type mChatServerRepositoryMockSendMessage struct {
	optional           bool
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockSendMessageExpectation
	expectations       []*ChatServerRepositoryMockSendMessageExpectation

	callArgs []*ChatServerRepositoryMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServerRepositoryMockSendMessageExpectation specifies expectation struct of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageExpectation struct {
	mock               *ChatServerRepositoryMock
	params             *ChatServerRepositoryMockSendMessageParams
	paramPtrs          *ChatServerRepositoryMockSendMessageParamPtrs
	expectationOrigins ChatServerRepositoryMockSendMessageExpectationOrigins
	results            *ChatServerRepositoryMockSendMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServerRepositoryMockSendMessageParams contains parameters of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageParams struct {
	ctx     context.Context
	message model.MessageInfo
}

// ChatServerRepositoryMockSendMessageParamPtrs contains pointers to parameters of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageParamPtrs struct {
	ctx     *context.Context
	message *model.MessageInfo
}

// ChatServerRepositoryMockSendMessageResults contains results of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageResults struct {
	err error
}

// ChatServerRepositoryMockSendMessageOrigins contains origins of expectations of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageExpectationOrigins struct {
	origin        string
	originCtx     string
	originMessage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Optional() *mChatServerRepositoryMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Expect(ctx context.Context, message model.MessageInfo) *mChatServerRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatServerRepositoryMockSendMessageParams{ctx, message}
	mmSendMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatServerRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServerRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectMessageParam2 sets up expected param message for ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) ExpectMessageParam2(message model.MessageInfo) *mChatServerRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServerRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.message = &message
	mmSendMessage.defaultExpectation.expectationOrigins.originMessage = minimock.CallerInfo(1)

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Inspect(f func(ctx context.Context, message model.MessageInfo)) *mChatServerRepositoryMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Return(err error) *ChatServerRepositoryMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerRepositoryMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServerRepositoryMockSendMessageResults{err}
	mmSendMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatServerRepository.SendMessage method
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Set(f func(ctx context.Context, message model.MessageInfo) (err error)) *ChatServerRepositoryMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	mmSendMessage.mock.funcSendMessageOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// When sets expectation for the ChatServerRepository.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServerRepositoryMockSendMessage) When(ctx context.Context, message model.MessageInfo) *ChatServerRepositoryMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockSendMessageExpectation{
		mock:               mmSendMessage.mock,
		params:             &ChatServerRepositoryMockSendMessageParams{ctx, message},
		expectationOrigins: ChatServerRepositoryMockSendMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockSendMessageExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockSendMessageResults{err}
	return e.mock
}

// Times sets number of times ChatServerRepository.SendMessage should be invoked
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Times(n uint64) *mChatServerRepositoryMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatServerRepositoryMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	mmSendMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessage
}

func (mmSendMessage *mChatServerRepositoryMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements mm_repository.ChatServerRepository
func (mmSendMessage *ChatServerRepositoryMock) SendMessage(ctx context.Context, message model.MessageInfo) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	mmSendMessage.t.Helper()

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, message)
	}

	mm_params := ChatServerRepositoryMockSendMessageParams{ctx, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServerRepositoryMockSendMessageParams{ctx, message}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatServerRepositoryMock.SendMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.message != nil && !minimock.Equal(*mm_want_ptrs.message, mm_got.message) {
				mmSendMessage.t.Errorf("ChatServerRepositoryMock.SendMessage got unexpected parameter message, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originMessage, *mm_want_ptrs.message, mm_got.message, minimock.Diff(*mm_want_ptrs.message, mm_got.message))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServerRepositoryMock.SendMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServerRepositoryMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServerRepositoryMock.SendMessage. %v %v", ctx, message)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServerRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatServerRepositoryMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServerRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatServerRepositoryMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Calls() []*ChatServerRepositoryMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.SendMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.SendMessage at\n%s", m.SendMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.SendMessage at\n%s with params: %#v", m.SendMessageMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServerRepositoryMock.SendMessage at\n%s", m.funcSendMessageOrigin)
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServerRepositoryMock.SendMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), m.SendMessageMock.expectedInvocationsOrigin, afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServerRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateRequestInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockMakeLogInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServerRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServerRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateRequestDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockMakeLogDone() &&
		m.MinimockSendMessageDone()
}
